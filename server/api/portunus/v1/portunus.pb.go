// Portunus — shared message contract
//
// This file is the single source of truth for the wire format between the
// Portunus server and ESP32 access modules.  Both sides generate code from
// this file:
//
//   Server (Go):  protoc  + protoc-gen-go
//   ESP32  (C):   protoc  + nanopb generator  (see ../nanopb/portunus.options)
//
// The access module sends Nanopb-encoded messages over HTTP/1.1 with
// Content-Type: application/x-protobuf.  No gRPC service block is defined
// because the ESP32 does not use HTTP/2.
//
// ─── Compatibility rules ───────────────────────────────────────────────────
//   • Only APPEND new fields (never reorder or reuse a field number).
//   • Mark removed fields as `reserved`.
//   • Keep optional semantics where the ESP32 may not have the data
//     (e.g. door_closed before a reed-switch is wired).
// ───────────────────────────────────────────────────────────────────────────

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: portunus/v1/portunus.proto

package portunusv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Sent by the access module at a regular interval to report health
// telemetry and confirm connectivity.
//
// Server Go equivalent: types.HeartbeatRequest
type HeartbeatRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for the access module (required).
	// Corresponds to PORTUNUS_MAX_NAME_LEN (32 chars) on the device.
	ModuleId string `protobuf:"bytes,1,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Firmware version string, e.g. "0.1.0-mvp".
	FirmwareVersion string `protobuf:"bytes,2,opt,name=firmware_version,json=firmwareVersion,proto3" json:"firmware_version,omitempty"`
	// Seconds since the module booted (esp_timer / 1e6 on ESP32).
	// uint64 matches the Go type; the ESP32 populates the lower 32 bits.
	UptimeS uint64 `protobuf:"varint,3,opt,name=uptime_s,json=uptimeS,proto3" json:"uptime_s,omitempty"`
	// Reed-switch state.  Omitted when no reed switch is installed.
	DoorClosed *bool `protobuf:"varint,4,opt,name=door_closed,json=doorClosed,proto3,oneof" json:"door_closed,omitempty"`
	// WiFi RSSI in dBm.  Omitted when unavailable.
	RssiDbm *int32 `protobuf:"varint,5,opt,name=rssi_dbm,json=rssiDbm,proto3,oneof" json:"rssi_dbm,omitempty"`
	// IP address of the module (IPv4 dotted-quad or IPv6).
	Ip string `protobuf:"bytes,6,opt,name=ip,proto3" json:"ip,omitempty"`
	// Free heap in bytes at the time of the heartbeat.
	FreeHeapBytes uint32 `protobuf:"varint,7,opt,name=free_heap_bytes,json=freeHeapBytes,proto3" json:"free_heap_bytes,omitempty"`
	// Monotonically increasing heartbeat counter (resets on reboot).
	Sequence      uint32 `protobuf:"varint,8,opt,name=sequence,proto3" json:"sequence,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeartbeatRequest) Reset() {
	*x = HeartbeatRequest{}
	mi := &file_portunus_v1_portunus_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeartbeatRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeartbeatRequest) ProtoMessage() {}

func (x *HeartbeatRequest) ProtoReflect() protoreflect.Message {
	mi := &file_portunus_v1_portunus_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeartbeatRequest.ProtoReflect.Descriptor instead.
func (*HeartbeatRequest) Descriptor() ([]byte, []int) {
	return file_portunus_v1_portunus_proto_rawDescGZIP(), []int{0}
}

func (x *HeartbeatRequest) GetModuleId() string {
	if x != nil {
		return x.ModuleId
	}
	return ""
}

func (x *HeartbeatRequest) GetFirmwareVersion() string {
	if x != nil {
		return x.FirmwareVersion
	}
	return ""
}

func (x *HeartbeatRequest) GetUptimeS() uint64 {
	if x != nil {
		return x.UptimeS
	}
	return 0
}

func (x *HeartbeatRequest) GetDoorClosed() bool {
	if x != nil && x.DoorClosed != nil {
		return *x.DoorClosed
	}
	return false
}

func (x *HeartbeatRequest) GetRssiDbm() int32 {
	if x != nil && x.RssiDbm != nil {
		return *x.RssiDbm
	}
	return 0
}

func (x *HeartbeatRequest) GetIp() string {
	if x != nil {
		return x.Ip
	}
	return ""
}

func (x *HeartbeatRequest) GetFreeHeapBytes() uint32 {
	if x != nil {
		return x.FreeHeapBytes
	}
	return 0
}

func (x *HeartbeatRequest) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

// Returned by the server to acknowledge the heartbeat.
//
// Server Go equivalent: types.HeartbeatResponse
type HeartbeatResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Always true on a successful heartbeat.
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	// Whether the module_id is registered in the device registry.
	Known bool `protobuf:"varint,2,opt,name=known,proto3" json:"known,omitempty"`
	// Echoed module_id.
	ModuleId string `protobuf:"bytes,3,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Server wall-clock time (RFC 3339 with nanoseconds).
	ServerTime    string `protobuf:"bytes,4,opt,name=server_time,json=serverTime,proto3" json:"server_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeartbeatResponse) Reset() {
	*x = HeartbeatResponse{}
	mi := &file_portunus_v1_portunus_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeartbeatResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeartbeatResponse) ProtoMessage() {}

func (x *HeartbeatResponse) ProtoReflect() protoreflect.Message {
	mi := &file_portunus_v1_portunus_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeartbeatResponse.ProtoReflect.Descriptor instead.
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return file_portunus_v1_portunus_proto_rawDescGZIP(), []int{1}
}

func (x *HeartbeatResponse) GetOk() bool {
	if x != nil {
		return x.Ok
	}
	return false
}

func (x *HeartbeatResponse) GetKnown() bool {
	if x != nil {
		return x.Known
	}
	return false
}

func (x *HeartbeatResponse) GetModuleId() string {
	if x != nil {
		return x.ModuleId
	}
	return ""
}

func (x *HeartbeatResponse) GetServerTime() string {
	if x != nil {
		return x.ServerTime
	}
	return ""
}

// Sent by the access module when a card is presented to the reader.
//
// Server Go equivalent: types.AccessRequest
type AccessRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for the access module (required).
	ModuleId string `protobuf:"bytes,1,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Hex-encoded card UID, e.g. "04:A3:2B:1C" (required).
	CardId string `protobuf:"bytes,2,opt,name=card_id,json=cardId,proto3" json:"card_id,omitempty"`
	// Reed-switch state at the moment of the read.
	DoorClosed *bool `protobuf:"varint,3,opt,name=door_closed,json=doorClosed,proto3,oneof" json:"door_closed,omitempty"`
	// Device-local timestamp of the read (ISO 8601 / RFC 3339).
	// Optional because the module may not have an RTC.
	RequestedAt   string `protobuf:"bytes,4,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AccessRequest) Reset() {
	*x = AccessRequest{}
	mi := &file_portunus_v1_portunus_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccessRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessRequest) ProtoMessage() {}

func (x *AccessRequest) ProtoReflect() protoreflect.Message {
	mi := &file_portunus_v1_portunus_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessRequest.ProtoReflect.Descriptor instead.
func (*AccessRequest) Descriptor() ([]byte, []int) {
	return file_portunus_v1_portunus_proto_rawDescGZIP(), []int{2}
}

func (x *AccessRequest) GetModuleId() string {
	if x != nil {
		return x.ModuleId
	}
	return ""
}

func (x *AccessRequest) GetCardId() string {
	if x != nil {
		return x.CardId
	}
	return ""
}

func (x *AccessRequest) GetDoorClosed() bool {
	if x != nil && x.DoorClosed != nil {
		return *x.DoorClosed
	}
	return false
}

func (x *AccessRequest) GetRequestedAt() string {
	if x != nil {
		return x.RequestedAt
	}
	return ""
}

// Returned by the server with the access decision.
//
// Server Go equivalent: types.AccessResponse
type AccessResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// True if the request was processed without internal error.
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	// Whether the module_id is registered in the device registry.
	Known bool `protobuf:"varint,2,opt,name=known,proto3" json:"known,omitempty"`
	// The access decision: true = unlock, false = deny.
	Granted bool `protobuf:"varint,3,opt,name=granted,proto3" json:"granted,omitempty"`
	// Human-readable reason code: "allow_all", "card_allowed",
	// "card_not_allowed", "unknown_module", "denied".
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// Echoed module_id.
	ModuleId string `protobuf:"bytes,5,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Server wall-clock time (RFC 3339 with nanoseconds).
	ServerTime    string `protobuf:"bytes,6,opt,name=server_time,json=serverTime,proto3" json:"server_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AccessResponse) Reset() {
	*x = AccessResponse{}
	mi := &file_portunus_v1_portunus_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccessResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessResponse) ProtoMessage() {}

func (x *AccessResponse) ProtoReflect() protoreflect.Message {
	mi := &file_portunus_v1_portunus_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessResponse.ProtoReflect.Descriptor instead.
func (*AccessResponse) Descriptor() ([]byte, []int) {
	return file_portunus_v1_portunus_proto_rawDescGZIP(), []int{3}
}

func (x *AccessResponse) GetOk() bool {
	if x != nil {
		return x.Ok
	}
	return false
}

func (x *AccessResponse) GetKnown() bool {
	if x != nil {
		return x.Known
	}
	return false
}

func (x *AccessResponse) GetGranted() bool {
	if x != nil {
		return x.Granted
	}
	return false
}

func (x *AccessResponse) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *AccessResponse) GetModuleId() string {
	if x != nil {
		return x.ModuleId
	}
	return ""
}

func (x *AccessResponse) GetServerTime() string {
	if x != nil {
		return x.ServerTime
	}
	return ""
}

var File_portunus_v1_portunus_proto protoreflect.FileDescriptor

const file_portunus_v1_portunus_proto_rawDesc = "" +
	"\n" +
	"\x1aportunus/v1/portunus.proto\x12\vportunus.v1\"\xac\x02\n" +
	"\x10HeartbeatRequest\x12\x1b\n" +
	"\tmodule_id\x18\x01 \x01(\tR\bmoduleId\x12)\n" +
	"\x10firmware_version\x18\x02 \x01(\tR\x0ffirmwareVersion\x12\x19\n" +
	"\buptime_s\x18\x03 \x01(\x04R\auptimeS\x12$\n" +
	"\vdoor_closed\x18\x04 \x01(\bH\x00R\n" +
	"doorClosed\x88\x01\x01\x12\x1e\n" +
	"\brssi_dbm\x18\x05 \x01(\x05H\x01R\arssiDbm\x88\x01\x01\x12\x0e\n" +
	"\x02ip\x18\x06 \x01(\tR\x02ip\x12&\n" +
	"\x0ffree_heap_bytes\x18\a \x01(\rR\rfreeHeapBytes\x12\x1a\n" +
	"\bsequence\x18\b \x01(\rR\bsequenceB\x0e\n" +
	"\f_door_closedB\v\n" +
	"\t_rssi_dbm\"w\n" +
	"\x11HeartbeatResponse\x12\x0e\n" +
	"\x02ok\x18\x01 \x01(\bR\x02ok\x12\x14\n" +
	"\x05known\x18\x02 \x01(\bR\x05known\x12\x1b\n" +
	"\tmodule_id\x18\x03 \x01(\tR\bmoduleId\x12\x1f\n" +
	"\vserver_time\x18\x04 \x01(\tR\n" +
	"serverTime\"\x9e\x01\n" +
	"\rAccessRequest\x12\x1b\n" +
	"\tmodule_id\x18\x01 \x01(\tR\bmoduleId\x12\x17\n" +
	"\acard_id\x18\x02 \x01(\tR\x06cardId\x12$\n" +
	"\vdoor_closed\x18\x03 \x01(\bH\x00R\n" +
	"doorClosed\x88\x01\x01\x12!\n" +
	"\frequested_at\x18\x04 \x01(\tR\vrequestedAtB\x0e\n" +
	"\f_door_closed\"\xa6\x01\n" +
	"\x0eAccessResponse\x12\x0e\n" +
	"\x02ok\x18\x01 \x01(\bR\x02ok\x12\x14\n" +
	"\x05known\x18\x02 \x01(\bR\x05known\x12\x18\n" +
	"\agranted\x18\x03 \x01(\bR\agranted\x12\x16\n" +
	"\x06reason\x18\x04 \x01(\tR\x06reason\x12\x1b\n" +
	"\tmodule_id\x18\x05 \x01(\tR\bmoduleId\x12\x1f\n" +
	"\vserver_time\x18\x06 \x01(\tR\n" +
	"serverTimeB;Z9github.com/BrandonDHaskell/Portunus/server/api/portunusv1b\x06proto3"

var (
	file_portunus_v1_portunus_proto_rawDescOnce sync.Once
	file_portunus_v1_portunus_proto_rawDescData []byte
)

func file_portunus_v1_portunus_proto_rawDescGZIP() []byte {
	file_portunus_v1_portunus_proto_rawDescOnce.Do(func() {
		file_portunus_v1_portunus_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_portunus_v1_portunus_proto_rawDesc), len(file_portunus_v1_portunus_proto_rawDesc)))
	})
	return file_portunus_v1_portunus_proto_rawDescData
}

var file_portunus_v1_portunus_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_portunus_v1_portunus_proto_goTypes = []any{
	(*HeartbeatRequest)(nil),  // 0: portunus.v1.HeartbeatRequest
	(*HeartbeatResponse)(nil), // 1: portunus.v1.HeartbeatResponse
	(*AccessRequest)(nil),     // 2: portunus.v1.AccessRequest
	(*AccessResponse)(nil),    // 3: portunus.v1.AccessResponse
}
var file_portunus_v1_portunus_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_portunus_v1_portunus_proto_init() }
func file_portunus_v1_portunus_proto_init() {
	if File_portunus_v1_portunus_proto != nil {
		return
	}
	file_portunus_v1_portunus_proto_msgTypes[0].OneofWrappers = []any{}
	file_portunus_v1_portunus_proto_msgTypes[2].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_portunus_v1_portunus_proto_rawDesc), len(file_portunus_v1_portunus_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_portunus_v1_portunus_proto_goTypes,
		DependencyIndexes: file_portunus_v1_portunus_proto_depIdxs,
		MessageInfos:      file_portunus_v1_portunus_proto_msgTypes,
	}.Build()
	File_portunus_v1_portunus_proto = out.File
	file_portunus_v1_portunus_proto_goTypes = nil
	file_portunus_v1_portunus_proto_depIdxs = nil
}
